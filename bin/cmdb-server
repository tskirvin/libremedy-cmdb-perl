#!/usr/bin/perl
# Copyright and license are in the documentation below.

=head1 NAME

cmdb-server - maintain an active connection to the Remedy CMDB

=head1 SYNOPSIS

B<cmdb-server> [--debug]

=head1 DESCRIPTION

[...]

=cut

##############################################################################
### Configuration ############################################################
##############################################################################

## Modify and uncomment this to use user modules instead of system-wide
## ones.  You'll need this unless you're installing as root.
# use lib '/FULL/PATH/TO/PERL/MODULES';

## Print debugging information?  Set with '--debug', can be set many times
our $DEBUG = 0;

## How many children should we allow running at a time?  This also works
## out to the maximum number of processes.
our $KIDS_MAX = 5;

## How long should it take before a connection times out?  This should be
## set to slightly below the lower-bound of the timeouts of any of the
## servers you connect to; the number is in seconds.
our $TIMEOUT = 10;

### How many seconds should we wait for a single spawned process to run?
our $ALARM = 60;

## Maximum number of times to retry a server connection.
our $MAX_RETRY = 10;

##############################################################################
### Declarations #############################################################
##############################################################################

use strict;
use warnings;

use Getopt::Long;
use Remedy::CMDB::Config;
use Remedy::CMDB::Server;
use IO::Socket;

use POSIX qw(:sys_wait_h :signal_h :errno_h);

$0 =~ s%.*/%%g;     # Lose the annoying path information
$|++;               # Flush output

###############################################################################
### main() ####################################################################
###############################################################################

our $LOGGER = Remedy::CMDB::Log->get_logger;

my $parser = Getopt::Long::Parser->new;
my $result = $parser->getoptions (
    'd|debug+'      => \$DEBUG,
    'man'           => sub { pod2usage (-verbose => 2, -noperldoc => 1) },
    'h|help'        => sub { pod2usage (-verbose => 1) }) || _error_usage ();

$SIG{CHLD} = \&reaper; 		   # Set what to do when the children die.

our $server = Remedy::CMDB::Server->connect (
    'debug'     => $DEBUG
) || $LOGGER->logdie ("Couldn't initialize the server: $@");

my $logger = $server->logger_or_die;

$logger->debug ("server is listening");

our $count    = 0;
our $CHILDREN = 0;

my $socket = $server->socket;

# Accept and process the connections

while (1) { 
    my $client = $server->socket->accept;
    next unless $client && defined fileno $client;
    while ($CHILDREN >= $KIDS_MAX) { sleep 1 }  # Only allow $MAXKIDS servers
    $count++;

    $logger->info ("accepting connection ($count)");

    my $pid = fork_client ($client);
    if ($pid) {
        $CHILDREN++;
        my $string = sprintf ('forked item %d (pid %d)', $count, $pid);
        $logger->debug ($string);
        next;
    } 

    $server->socket_close;
    $logger->info  ("connection $count established");

    $SIG{ALRM} = sub { exit_error ("submit time of $ALARM secs exceeded") }; 
    alarm $ALARM;

    my @input;
    while (my $line = <$client>) { 
        push @input, $line;
        last if ($line =~ /^<\/cmdb-client>$/);
        last if ($line eq '.');
    }
    $client->shutdown (0);  # no more reading

    my @return = $server->process ($client, @input);
    foreach (@return) { print $client $_ }

    $client->shutdown (2);  # no more writing either

    $client->flush;
    $client->close;
    exit 0;
}

$logger->warn ("$CHILDREN children still open");
$server->server_close;
exit 0;

###############################################################################
### Functions #################################################################
###############################################################################

### fork_client (FH[, COUNT])
# Wraps fork ().  Takes an open filehandle FH, and an optional count.  On
# success, returns the valid PID to the child, and 0 to the parent.  Dies on
# failure.  $LOGGER must exist. 
# We do have a retry mechanism if the forking has a small error.
sub fork_client {
    my ($fh, $count) = @_;
    $count ||= 0;
    return unless $fh && defined fileno $fh;

    $LOGGER->logdie ("fork: too many retries ($count)") if $count > $MAX_RETRY;

    my $pid = fork;
    ## Success, and we're the parent: close the filehandle, and return
    if    ($pid)         { close $fh && return $pid } 

    ## Success, and we're the child: return the pid
    elsif (defined $pid) { return 0 }

    ## Error, but it's a 'do again'; so let's wait a second and do so.
    elsif ($! == EAGAIN) { sleep 1 && return fork_client ($fh, ++$count) }
    
    ## fork error
    else                 { $LOGGER->logdie ("fork error: $!\n"); }
}

### reaper (PID)
# Takes care of cleaning up the children processes.
sub reaper {
    my $child = waitpid (-1, WNOHANG);

    ## no child waiting; ignore
    if ($child == -1) { return }
    
    ## the process exited 
    elsif (WIFEXITED ($?)) { 
        $CHILDREN--;
        $LOGGER->debug ("reaped $child" . ($? ? " with exit $?" : ''));
        reaper ();
        $SIG{CHLD} = \&reaper;
    }

    ## false alarm; ignore
    else { return }
}

##############################################################################
### Final Documentation ######################################################
##############################################################################

=head1 REQUIREMENTS

=head1 SEE ALSO

=head1 TODO

=head1 AUTHOR

Tim Skirvin <tskirvin@stanford.edu>

=head1 LICENSE

Copyright 2009 Board of Trustees, Leland Stanford Jr. University

This program is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.

=cut
